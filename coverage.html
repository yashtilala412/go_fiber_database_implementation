
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>fiber-csv-app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/app.go (0.0%)</option>
				
				<option value="file1">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/cli/api.go (0.0%)</option>
				
				<option value="file2">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/cli/main.go (0.0%)</option>
				
				<option value="file3">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/cli/migration.go (0.0%)</option>
				
				<option value="file4">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/cli/seed.go (0.0%)</option>
				
				<option value="file5">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config/main.go (0.0%)</option>
				
				<option value="file6">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/controllers/api/v1/app_controller.go (44.9%)</option>
				
				<option value="file7">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/controllers/api/v1/health_controller.go (50.0%)</option>
				
				<option value="file8">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/controllers/api/v1/review_controller.go (3.8%)</option>
				
				<option value="file9">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/database/main.go (0.0%)</option>
				
				<option value="file10">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/database/seed.go (0.0%)</option>
				
				<option value="file11">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/docs/docs.go (0.0%)</option>
				
				<option value="file12">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/logger/main.go (0.0%)</option>
				
				<option value="file13">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/middlewares/http_logger.go (0.0%)</option>
				
				<option value="file14">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/middlewares/middleware.go (0.0%)</option>
				
				<option value="file15">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/models/app.go (0.0%)</option>
				
				<option value="file16">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/models/review.go (0.0%)</option>
				
				<option value="file17">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/pkg/prometheus/prometheus.go (0.0%)</option>
				
				<option value="file18">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/routes/main.go (0.0%)</option>
				
				<option value="file19">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/routinewrapper/wrapper.go (0.0%)</option>
				
				<option value="file20">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/utils/json_response.go (0.0%)</option>
				
				<option value="file21">git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/utils/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Golang API.
//
//        Schemes: https
//        Host: localhost
//        BasePath: /api/v1
//        Version: 0.0.1-alpha
//
//        Consumes:
//        - application/json
//
//        Produces:
//        - application/json
//
// swagger:meta
package main

import (
        "time"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/cli"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/logger"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/routinewrapper"
        "github.com/getsentry/sentry-go"
        "go.uber.org/zap"
)

func main() <span class="cov0" title="0">{
        // Collecting config from env or file or flag
        cfg := config.GetConfig()

        logger, err := logger.NewRootLogger(cfg.Debug, cfg.IsDevelopment)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">zap.ReplaceGlobals(logger)

        // this function will logged error log in sentry
        sentryLoggedFunc := func() </span><span class="cov0" title="0">{
                err := recover()

                if err != nil </span><span class="cov0" title="0">{
                        sentry.CurrentHub().Recover(err)
                        sentry.Flush(time.Second * 2)
                }</span>
        }

        // routine wrapper will handle go routine error also an log into sentry
        <span class="cov0" title="0">routinewrapper.Init(sentryLoggedFunc)
        defer sentryLoggedFunc()

        err = cli.Init(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "os"
        "os/signal"
        "syscall"

        "go.uber.org/zap"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/database"

        _ "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/docs"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/routes"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/swagger"
        "github.com/spf13/cobra"

        pMetrics "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/pkg/prometheus"
)

// GetAPICommandDef runs app
func GetAPICommandDef(cfg config.AppConfig, logger *zap.Logger) cobra.Command <span class="cov0" title="0">{
        apiCommand := cobra.Command{
                Use:   "api",
                Short: "To start api",
                Long:  `To start api`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{

                        // Create fiber app
                        app := fiber.New(fiber.Config{})
                        app.Get("/swagger/*", swagger.HandlerDefault) // Serve Swagger UI
                        promMetrics := pMetrics.InitPrometheusMetrics()

                        // Database connection
                        db, err := database.Connect(cfg.DB)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Setup routes
                        <span class="cov0" title="0">err = routes.Setup(app, db, logger, promMetrics)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">interrupt := make(chan os.Signal, 1)
                        signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)

                        // Start server in a goroutine
                        go func() </span><span class="cov0" title="0">{
                                if err := app.Listen(cfg.Host + ":" + cfg.Port); err != nil </span><span class="cov0" title="0">{
                                        logger.Panic(err.Error())
                                }</span>
                        }()

                        <span class="cov0" title="0">&lt;-interrupt
                        logger.Info("gracefully shutting down...")
                        if err := app.Shutdown(); err != nil </span><span class="cov0" title="0">{
                                logger.Panic("error while shutting down server", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">logger.Info("server stopped receiving new requests.")
                        return nil</span>
                },
        }

        <span class="cov0" title="0">return apiCommand</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cli

import (
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

// Init app initialization
func Init(cfg config.AppConfig, logger *zap.Logger) error <span class="cov0" title="0">{
        migrationCmd := GetMigrationCommandDef(cfg)
        apiCmd := GetAPICommandDef(cfg, logger)
        seedCmd := GetSeedCommandDef(cfg) // Add the seed command

        rootCmd := &amp;cobra.Command{Use: "golang-api"}
        rootCmd.AddCommand(&amp;migrationCmd, &amp;apiCmd, &amp;seedCmd)
        return rootCmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "database/sql"
        "fmt"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/database"
        _ "github.com/lib/pq" // for postgres dialect
        migrate "github.com/rubenv/sql-migrate"
        "github.com/spf13/cobra"
)

// GetMigrationCommandDef initialize migration command
func GetMigrationCommandDef(cfg config.AppConfig) cobra.Command <span class="cov0" title="0">{
        migrateCmd := cobra.Command{
                Use:   "migrate [sub command]",
                Short: "To run db migrate",
                Long: `This command is used to run database migration.
        It has up and down sub commands`,
                Args: cobra.MinimumNArgs(1),
        }

        migrateUp := cobra.Command{
                Use:   "up",
                Short: "It will apply migration(s)",
                Long:  `It will run all remaining migration(s)`,
                Args:  cobra.MinimumNArgs(0),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Run test db migration

                        switch cfg.DB.Dialect </span>{
                        case database.POSTGRES:<span class="cov0" title="0">
                                return runPostgresMigration(cfg, "UP")</span>

                        }
                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov0" title="0">migrateDown := cobra.Command{
                Use:   "down",
                Short: "It will revert migration(s)",
                Long:  `It will run all remaining migration(s)`,
                Args:  cobra.MinimumNArgs(0),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Run test db migration

                        switch cfg.DB.Dialect </span>{
                        case database.POSTGRES:<span class="cov0" title="0">
                                return runPostgresMigration(cfg, "DOWN")</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
        }
        <span class="cov0" title="0">migrateCmd.AddCommand(&amp;migrateUp, &amp;migrateDown)
        // Migration commands up, down

        return migrateCmd</span>
}

func runPostgresMigration(cfg config.AppConfig, migrationType string) error <span class="cov0" title="0">{
        migrations := migrate.FileMigrationSource{
                Dir: cfg.DB.MigrationDir,
        }

        db, err := sql.Open(database.POSTGRES, fmt.Sprintf("postgres://%s:%s@%s:%d/%s?%s", cfg.DB.Username, cfg.DB.Password, cfg.DB.Host, cfg.DB.Port, cfg.DB.Db, cfg.DB.QueryString))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if migrationType == "UP" </span><span class="cov0" title="0">{
                _, err = migrate.Exec(db, database.POSTGRES, migrations, migrate.Up)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                _, err = migrate.Exec(db, database.POSTGRES, migrations, migrate.Down)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cli

import (
        "database/sql"
        "fmt"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/database"
        _ "github.com/lib/pq" // for postgres dialect
        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

// GetSeedCommandDef initializes the seed command
func GetSeedCommandDef(cfg config.AppConfig) cobra.Command <span class="cov0" title="0">{
        seedCmd := cobra.Command{
                Use:   "seed",
                Short: "Seed database with initial data",
                Long:  `This command reads data from CSV files and populates the database tables.`,
                Args:  cobra.MinimumNArgs(0),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        dbConnGoqu, err := database.Connect(cfg.DB)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to connect to database for seeding: %w", err)
                        }</span>

                        // Get the underlying *sql.DB for closing
                        <span class="cov0" title="0">if sqlDB, ok := dbConnGoqu.Db.(*sql.DB); ok </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                                                fmt.Println("Error closing database connection:", err)
                                        }</span>
                                }()
                        } else<span class="cov0" title="0"> {
                                fmt.Println("Warning: Could not access the underlying *sql.DB to close the connection.")
                        }</span>

                        <span class="cov0" title="0">err = database.SeedData(cfg, dbConnGoqu, &amp;zap.Logger{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to seed data: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println("Database seeding completed successfully!")
                        return nil</span>
                },
        }
        <span class="cov0" title="0">return seedCmd</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"
        "log"
        "os"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

// AllConfig variable of type AppConfig
var AllConfig AppConfig

// AppConfig type AppConfig
type AppConfig struct {
        IsDevelopment     bool   `envconfig:"IS_DEVELOPMENT"`
        Debug             bool   `envconfig:"DEBUG"`
        Host              string `envconfig:"HOST"`
        Port              string `envconfig:"APP_PORT"`
        DB                DBConfig
        AppDataCSVPath    string `envconfig:"APP_DATA_CSV_PATH"`
        ReviewDataCSVPath string `envconfig:"REVIEW_DATA_CSV_PATH"`
}

// GetConfig Collects all configs
func GetConfig() AppConfig <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("warning .env file not found, scanning from OS ENV")
        }</span>

        <span class="cov0" title="0">AllConfig = AppConfig{}

        err = envconfig.Process("APP_PORT", &amp;AllConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return AllConfig</span>
}

// GetConfigByName Collects all configs
func GetConfigByName(key string) string <span class="cov0" title="0">{
        err := godotenv.Load()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return os.Getenv(key)</span>
}

// LoadTestEnv loads environment variables from .env.testing file
func LoadTestEnv() AppConfig <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = godotenv.Load(fmt.Sprintf("%s/.env.testing", cwd))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return GetConfig()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/constants"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/models"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/utils"
        "github.com/doug-martin/goqu/v9"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"

        "github.com/gofiber/fiber/v2"
)

// AppController for app controllers
type AppController struct {
        appService *models.AppModel // Use the AppModel directly
        logger     *zap.Logger
}

// NewAppController returns a new AppController
func NewAppController(goqu *goqu.Database, logger *zap.Logger) (*AppController, error) <span class="cov8" title="1">{
        appModel, err := models.InitAppModel(goqu) // Initialize AppModel
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;AppController{
                appService: &amp;appModel, // Use the initialized AppModel
                logger:     logger,
        }, nil</span>
}

// GetApp retrieves a single app by ID.
//
//        @Summary                Get App
//        @Description        Fetches an app by its ID.
//        @Tags                        Apps
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path        int        true        "App ID"
//        @Success                200        {object}        models.App
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/apps/{id} [get]

func (ac *AppController) GetApp(c *fiber.Ctx) error <span class="cov0" title="0">{
        appID, err := c.ParamsInt(constants.ParamAppID) // Use c.ParamsInt
        if err != nil </span><span class="cov0" title="0">{
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidAppID)
        }</span>

        <span class="cov0" title="0">app, err := ac.appService.GetAppById(appID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return utils.JSONFail(c, http.StatusNotFound, constants.ErrorAppNotFound)
                }</span>
                <span class="cov0" title="0">ac.logger.Error("error while get app by id", zap.Int("id", appID), zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.FailedToGetApp)</span>
        }
        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, app)</span>
}

// GetApps fetches a list of apps.
//
//        @Summary                Get Apps
//        @Description        Retrieves a paginated list of apps from the database.
//        @Tags                        Apps
//        @Accept                        json
//        @Produce                json
//        @Param                        limit        query                int        false        "Number of records to return"
//        @Param                        page        query                int        false        "Page number"
//        @Success                200        {array}        models.App
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/apps [get]

func (ac *AppController) GetApps(c *fiber.Ctx) error <span class="cov8" title="1">{
        const MaxLimit = 500 // Set maximum allowed limit

        limit, err := strconv.Atoi(c.Query("limit", strconv.Itoa(constants.DefaultLimit)))
        if err != nil || limit &lt;= 0 </span><span class="cov8" title="1">{
                ac.logger.Error("Invalid limit parameter", zap.String("limit", c.Query("limit")), zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidLimit)
        }</span>

        // Check if limit exceeds MaxLimit
        <span class="cov8" title="1">if limit &gt; MaxLimit </span><span class="cov8" title="1">{
                ac.logger.Warn("Requested limit exceeds maximum", zap.Int("limit", limit))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorlimitAccess)
        }</span>

        <span class="cov8" title="1">offset, err := strconv.Atoi(c.Query("offset", strconv.Itoa(constants.DefaultOffset)))
        if err != nil </span><span class="cov8" title="1">{
                ac.logger.Error("Invalid offset parameter", zap.String("offset", c.Query("offset")), zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidOffset)
        }</span>

        <span class="cov8" title="1">apps, err := ac.appService.GetApps(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Failed to get apps", zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.FailedToGetApp)
        }</span>

        <span class="cov8" title="1">return utils.JSONSuccess(c, http.StatusOK, apps)</span>
}

// CreateApp creates a new app.
//
//        @Summary                Create App
//        @Description        Creates a new application entry in the database.
//        @Tags                        Apps
//        @Accept                        json
//        @Produce                json
//        @Param                        app        body                models.App        true        "App data to create"
//        @Success                201        {object}        models.App
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/apps [post]

func (ac *AppController) CreateApp(c *fiber.Ctx) error <span class="cov8" title="1">{
        var appReq models.App // Use the App struct from your models

        // Parse the request body into the App struct.
        err := json.Unmarshal(c.Body(), &amp;appReq)
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Error unmarshalling request body", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidRequestBody+err.Error())
        }</span>

        // Validate the request body.
        <span class="cov8" title="1">validate := validator.New()
        err = validate.Struct(appReq)
        if err != nil </span><span class="cov8" title="1">{
                ac.logger.Error("Validation error", zap.Error(err))
                validationErrors := utils.ValidatorErrorString(err)
                return utils.JSONError(c, http.StatusBadRequest, validationErrors) //  Adapt this as needed.  Send the validation errors.
        }</span>

        // Insert the app data into the database.
        <span class="cov8" title="1">insertedApp, err := ac.appService.InsertApps(appReq)
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Error inserting app data", zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.ErrorFiledToCreateApp) //Use a constant
        }</span>

        // Return the newly created app data, including the generated ID.
        <span class="cov8" title="1">return utils.JSONSuccess(c, http.StatusCreated, insertedApp)</span>
}

// DeleteApp deletes an app by ID.
//
//        @Summary                Delete App
//        @Description        Removes an app from the database.
//        @Tags                        Apps
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path        int        true        "App ID"
//        @Success                200        {object}        utils.JSONResponse
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/apps/{id} [delete]

func (ac *AppController) DeleteApp(c *fiber.Ctx) error <span class="cov8" title="1">{
        id, err := strconv.Atoi(c.Params(constants.ParamAppID))
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Error parsing app ID", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidAppID)
        }</span>

        <span class="cov8" title="1">err = ac.appService.DeleteApp(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        ac.logger.Warn("App not found", zap.Int("id", id))
                        return utils.JSONError(c, http.StatusNotFound, constants.ErrorAppNotFound)
                }</span>
                <span class="cov0" title="0">ac.logger.Error("Error deleting app", zap.Error(err), zap.Int("id", id))
                return utils.JSONError(c, http.StatusInternalServerError, constants.ErrorFaiedToDeleteApp)</span>
        }

        <span class="cov8" title="1">return utils.JSONSuccess(c, http.StatusOK, constants.AppsDeletedSuccessfully)</span>
}

// UpdateApp updates an existing app.
//
//        @Summary                Update App
//        @Description        Updates app data in the database.
//        @Tags                        Apps
//        @Accept                        json
//        @Produce                json
//        @Param                        id                path        int                        true        "App ID"
//        @Param                        app                body        models.App        true        "Updated app data"
//        @Success                200        {object}        models.App
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/apps/{id} [put]

func (ac *AppController) UpdateApp(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Params(constants.ParamAppID))
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Error parsing app ID", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidAppID)
        }</span>

        <span class="cov0" title="0">var updatedApp models.App
        if err := c.BodyParser(&amp;updatedApp); err != nil </span><span class="cov0" title="0">{
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidRequestBody)
        }</span>

        // Validate the request body.
        <span class="cov0" title="0">validate := validator.New()
        err = validate.Struct(updatedApp)
        if err != nil </span><span class="cov0" title="0">{
                return utils.JSONError(c, http.StatusBadRequest, utils.ValidatorErrorString(err)) //  Adapt this as needed
        }</span>

        <span class="cov0" title="0">updatedApp, err = ac.appService.UpdateApp(id, updatedApp)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        ac.logger.Warn("App not found", zap.Int("id", id))
                        return utils.JSONError(c, http.StatusNotFound, constants.ErrorAppNotFound)
                }</span>
                <span class="cov0" title="0">ac.logger.Error("Error updating app", zap.Error(err), zap.Int("id", id))
                return utils.JSONError(c, http.StatusInternalServerError, constants.ErrorFiledToUpdateApp)</span>
        }

        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, updatedApp)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package v1

import (
        "context"
        "net/http"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/constants"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/utils"
        "github.com/doug-martin/goqu/v9"
        "github.com/gofiber/fiber/v2"
        "go.uber.org/zap"
)

type HealthController struct {
        db     *goqu.Database
        logger *zap.Logger
}

func NewHealthController(db *goqu.Database, logger *zap.Logger) (*HealthController, error) <span class="cov8" title="1">{
        return &amp;HealthController{
                db:     db,
                logger: logger,
        }, nil
}</span>

// Overall check overall health of application as well as dependencies health check
// @Summary Overall health check
// @Description Overall health check of application as well as dependencies health check
// @Tags Healthcheck
// @ID overallHealthCheck
// @Produce json
// @Success 200 {object} utils.JSONResponse "Health check successful"
// @Failure 500 {object} utils.JSONResponse "Internal server error during health check"
// @Router /healthz [get]
func (hc *HealthController) Overall(ctx *fiber.Ctx) error <span class="cov8" title="1">{
        // --- Add this log to see if the handler is being reached ---
        hc.logger.Info("Received request for /healthz")
        // --- End Add ---

        err := healthDb(hc.db) // This checks the database
        if err != nil </span><span class="cov0" title="0">{
                // --- Add this log to see if the DB check failed ---
                hc.logger.Error("Database health check failed", zap.Error(err))
                // --- End Add ---
                return utils.JSONError(ctx, http.StatusInternalServerError, constants.ErrHealthCheckDb)
        }</span>

        // --- Add this log to confirm success ---
        <span class="cov8" title="1">hc.logger.Info("Database health check successful")
        // --- End Add ---

        return utils.JSONSuccess(ctx, http.StatusOK, "ok")</span>
}

// Self health check
// @Summary Self health check
// @Description Basic self health check without dependency checks.
// @Tags Healthcheck
// @ID selfHealthCheck
// @Produce json
// @Success 200 {object} utils.JSONResponse "Health check successful"
// @Router /healthz/self [get]
func (hc *HealthController) Self(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        return utils.JSONSuccess(ctx, http.StatusOK, "ok")
}</span>

// Database health check
// @Summary Database health check
// @Description Database health check
// @Tags Healthcheck
// @ID dbHealthCheck
// @Produce json
// @Success 200 {object} utils.JSONResponse "Database health check successful"
// @Failure 500 {object} utils.JSONResponse "Internal server error during database health check"
// @Router /healthz/db [get]
func (hc *HealthController) Db(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        err := healthDb(hc.db)
        if err != nil </span><span class="cov0" title="0">{
                hc.logger.Error("error while health checking of db", zap.Error(err))
                return utils.JSONError(ctx, http.StatusInternalServerError, constants.ErrHealthCheckDb)
        }</span>
        <span class="cov0" title="0">return utils.JSONSuccess(ctx, http.StatusOK, "ok")</span>
}

///////////////////////
// HealthCheck CORE
//////////////////////

func healthDb(db *goqu.Database) error <span class="cov8" title="1">{
        // Reverted to original implementation
        _, err := db.ExecContext(context.TODO(), "SELECT 1")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package v1

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "strconv"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/constants" // Import your constants
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/models"
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/utils"
        "github.com/doug-martin/goqu/v9"
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
        "go.uber.org/zap"
)

// ReviewController handles API requests related to review data.
type ReviewController struct {
        reviewService *models.ReviewModel
        logger        *zap.Logger
}

// NewReviewController returns a new ReviewController
func NewReviewController(goqu *goqu.Database, logger *zap.Logger) (*ReviewController, error) <span class="cov8" title="1">{
        reviewModel, err := models.InitReviewModel(goqu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ReviewController{
                reviewService: &amp;reviewModel,
                logger:        logger,
        }, nil</span>
}

// GetReviews retrieves a paginated list of reviews.
//
//        @Summary                Get Reviews
//        @Description        Fetches reviews from the database with pagination.
//        @Tags                        Reviews
//        @Accept                        json
//        @Produce                json
//        @Param                        limit        query        int        false        "Number of reviews to return"
//        @Param                        offset        query        int        false        "Offset for pagination"
//        @Success                200        {array}        models.Review
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/reviews [get]

func (rc *ReviewController) GetReviews(c *fiber.Ctx) error <span class="cov0" title="0">{
        const MaxLimit = 500 // Set maximum allowed limit

        limit, err := strconv.Atoi(c.Query("limit", strconv.Itoa(constants.DefaultLimit)))
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                rc.logger.Error("Invalid limit parameter", zap.String("limit", c.Query("limit")), zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidLimit)
        }</span>
        <span class="cov0" title="0">if limit &gt; MaxLimit </span><span class="cov0" title="0">{
                rc.logger.Warn("Requested limit exceeds maximum", zap.Int("limit", limit))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorlimitAccess)
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(c.Query("offset", strconv.Itoa(constants.DefaultOffset)))
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Invalid offset parameter", zap.String("offset", c.Query("offset")), zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidOffset)
        }</span>

        <span class="cov0" title="0">reviews, err := rc.reviewService.GetReviews(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Failed to get reviews", zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.FailedToGetReviews)
        }</span>

        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, reviews)</span>
}

// GetReview retrieves a review by ID.
//
//        @Summary                Get Review
//        @Description        Fetches a review using its ID.
//        @Tags                        Reviews
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path        int        true        "Review ID"
//        @Success                200        {object}        models.Review
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/reviews/{id} [get]

func (rc *ReviewController) GetReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        reviewID, err := c.ParamsInt(constants.ParamReviewID) //  c.ParamsInt
        if err != nil </span><span class="cov0" title="0">{
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidReviewID)
        }</span>

        <span class="cov0" title="0">review, err := rc.reviewService.GetReviewById(reviewID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return utils.JSONFail(c, http.StatusNotFound, constants.ErrorReviewNotFound)
                }</span>
                <span class="cov0" title="0">rc.logger.Error("error while get review by id", zap.Int("id", reviewID), zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.FailedToGetReview)</span>
        }
        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, review)</span>
}

// CreateReviewData adds a new review.
//
//        @Summary                Create Review
//        @Description        Creates a new review in the database.
//        @Tags                        Reviews
//        @Accept                        json
//        @Produce                json
//        @Param                        review        body        models.Review        true        "Review data to create"
//        @Success                201        {object}        models.Review
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/reviews [post]

func (rc *ReviewController) CreateReviewData(c *fiber.Ctx) error <span class="cov0" title="0">{
        var reviewReq models.Review

        err := json.Unmarshal(c.Body(), &amp;reviewReq)
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Error unmarshalling request body", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidRequestBody)
        }</span>

        <span class="cov0" title="0">validate := validator.New()
        err = validate.Struct(reviewReq)
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Validation error", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, utils.ValidatorErrorString(err))
        }</span>

        <span class="cov0" title="0">reviewToInsert := models.Review{
                App:                   reviewReq.App,
                TranslatedReview:      reviewReq.TranslatedReview,
                Sentiment:             reviewReq.Sentiment,
                SentimentPolarity:     reviewReq.SentimentPolarity,
                SentimentSubjectivity: reviewReq.SentimentSubjectivity,
        }

        insertedReview, err := rc.reviewService.InsertReviews(reviewToInsert)
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Error inserting review data", zap.Error(err))
                return utils.JSONError(c, http.StatusInternalServerError, constants.ErrorFiledToCreateReviewApp)
        }</span>

        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusCreated, insertedReview)</span>
}

// DeleteReview deletes a review by ID.
//
//        @Summary                Delete Review
//        @Description        Deletes a review by its ID.
//        @Tags                        Reviews
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path        int        true        "Review ID"
//        @Success                200        {object}        utils.JSONResponse
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/reviews/{id} [delete]

func (rc *ReviewController) DeleteReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Params(constants.ParamReviewID))
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Error parsing review ID", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidReviewID)
        }</span>

        <span class="cov0" title="0">err = rc.reviewService.DeleteApp(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        rc.logger.Warn("Review not found", zap.Int("id", id))
                        return utils.JSONError(c, http.StatusNotFound, constants.ErrorReviewNotFound)
                }</span>
                <span class="cov0" title="0">rc.logger.Error("Error deleting review", zap.Error(err), zap.Int("id", id))
                return utils.JSONError(c, http.StatusInternalServerError, constants.ErrorFaiedToDeleteReview)</span>
        }

        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, constants.ReviewsDeletedSuccessfully)</span>
}

// UpdateReview updates a review.
//
//        @Summary                Update Review
//        @Description        Updates an existing review in the database.
//        @Tags                        Reviews
//        @Accept                        json
//        @Produce                json
//        @Param                id                path                int                        true        "Review ID"
//        @Param                review        body                models.Review        true        "Updated review data"
//        @Success                200        {object}        models.Review
//        @Failure                400        {object}        utils.JSONResponse
//        @Failure                404        {object}        utils.JSONResponse
//        @Failure                500        {object}        utils.JSONResponse
//        @Router                        /api/v1/reviews/{id} [put]
func (rc *ReviewController) UpdateReview(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Params(constants.ParamReviewID))
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Error parsing review ID", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidReviewID)
        }</span>

        <span class="cov0" title="0">var updatedReview models.Review
        if err := json.Unmarshal(c.Body(), &amp;updatedReview); err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Error parsing request body", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, constants.ErrorInvalidRequestBody)
        }</span>

        // Validate the request body.
        <span class="cov0" title="0">validate := validator.New()
        err = validate.Struct(updatedReview)
        if err != nil </span><span class="cov0" title="0">{
                rc.logger.Error("Validation error", zap.Error(err))
                return utils.JSONError(c, http.StatusBadRequest, utils.ValidatorErrorString(err)) //  Adapt this as needed
        }</span>

        <span class="cov0" title="0">updatedReview, err = rc.reviewService.UpdateReview(id, updatedReview)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        rc.logger.Warn("Review not found", zap.Int("id", id))
                        return utils.JSONError(c, http.StatusNotFound, constants.ErrorReviewNotFound)
                }</span>
                <span class="cov0" title="0">rc.logger.Error("Error updating review", zap.Error(err), zap.Int("id", id))
                return utils.JSONError(c, http.StatusInternalServerError, constants.FailedToUpdateReviews)</span>
        }

        <span class="cov0" title="0">return utils.JSONSuccess(c, http.StatusOK, updatedReview)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "database/sql"
        "errors"
        "strconv"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "github.com/doug-martin/goqu/v9"
        _ "github.com/doug-martin/goqu/v9/dialect/postgres"
        _ "github.com/lib/pq"
)

var db *sql.DB
var dbURL string
var err error

const (
        POSTGRES = "postgres"
)

// Connect with database
func Connect(cfg config.DBConfig) (*goqu.Database, error) <span class="cov0" title="0">{
        switch cfg.Dialect </span>{
        case POSTGRES:<span class="cov0" title="0">
                return postgresDBConnection(cfg)</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("no suitable dialect found")</span>
        }
}
func postgresDBConnection(cfg config.DBConfig) (*goqu.Database, error) <span class="cov0" title="0">{
        dbURL = "postgres://" + cfg.Username + ":" + cfg.Password + "@" + cfg.Host + ":" + strconv.Itoa(cfg.Port) + "/" + cfg.Db + "?" + cfg.QueryString
        if db == nil </span><span class="cov0" title="0">{
                db, err = sql.Open(POSTGRES, dbURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return goqu.New(POSTGRES, db), err</span>
        }
        <span class="cov0" title="0">return goqu.New(POSTGRES, db), err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "encoding/csv"
        "fmt"
        "os"
        "strconv"
        "strings"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "github.com/doug-martin/goqu/v9"
        "go.uber.org/zap"
)

// SeedData reads data from CSV files and inserts it into the database.
func SeedData(cfg config.AppConfig, db *goqu.Database, logger *zap.Logger) error <span class="cov0" title="0">{
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        // Defer rollback, this will happen if any error occurs.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("Panic occurred during seeding, rolling back transaction", zap.Any("error", r))
                        if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to rollback transaction after panic", zap.Error(rbErr))
                        }</span>
                        <span class="cov0" title="0">panic(r)</span> // Re-panic to propagate.
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        // Rollback only if err is not nil
                        logger.Error("Error occurred during seeding, rolling back transaction", zap.Error(err))
                        if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to rollback transaction after error", zap.Error(rbErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Commit only if there was no error
                        if cErr := tx.Commit(); cErr != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to commit transaction", zap.Error(cErr))
                                err = cErr //important: set the error
                        }</span>
                }
        }()

        <span class="cov0" title="0">if err := seedAppData(cfg.AppDataCSVPath, tx, logger); err != nil </span><span class="cov0" title="0">{
                return err // Return the error from seedAppData
        }</span>

        <span class="cov0" title="0">if err := seedReviewData(cfg.ReviewDataCSVPath, tx, logger); err != nil </span><span class="cov0" title="0">{
                return err // Return the error from seedReviewData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func seedAppData(csvPath string, tx *goqu.TxDatabase, logger *zap.Logger) error <span class="cov0" title="0">{
        file, err := os.Open(csvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open app_data CSV file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        reader := csv.NewReader(file)
        _, err = reader.Read() // Read the header row and discard it
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read app_data CSV header: %w", err)
        }</span>

        <span class="cov0" title="0">expectedFields := 13

        var appData []map[string]interface{}
        for lineNum := 2; ; lineNum++ </span><span class="cov0" title="0">{
                row, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("Warning: Error reading app_data CSV row at line %d: %v\n", lineNum, err)
                        continue</span> // Skip rows with read errors other than EOF
                }

                <span class="cov0" title="0">if len(row) != expectedFields </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Skipping app_data row at line %d with %d fields (expected %d): %v\n", lineNum, len(row), expectedFields, row)
                        continue</span> // Skip the current row if the number of fields is wrong
                }

                <span class="cov0" title="0">var rating float64 // Change to float64, not pointer
                if row[2] != "NaN" </span><span class="cov0" title="0">{
                        rating, err = strconv.ParseFloat(row[2], 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Skipping row at line %d due to error parsing Rating: %v - Row: %v\n", lineNum, err, row)
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        rating = 0.0 // Default value for NaN
                }</span>

                <span class="cov0" title="0">reviews, err := strconv.Atoi(strings.ReplaceAll(row[3], ",", ""))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Skipping row at line %d due to error parsing Reviews: %v - Row: %v\n", lineNum, err, row)
                        continue</span>
                }

                <span class="cov0" title="0">data := map[string]interface{}{
                        "app":            row[0],
                        "category":       row[1],
                        "rating":         rating,
                        "reviews":        reviews,
                        "size":           row[4],
                        "installs":       row[5],
                        "type":           row[6],
                        "price":          row[7],
                        "content_rating": row[8],
                        "genres":         row[9],
                        "last_updated":   row[10],
                        "current_ver":    row[11],
                        "android_ver":    row[12],
                }
                appData = append(appData, data)
                fmt.Printf("Debug: Inserting row at line %d: %+v\n", lineNum, data)</span> // Debug log
        }

        <span class="cov0" title="0">_, err = tx.Insert("apps").Rows(appData).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert app_data: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func seedReviewData(csvPath string, tx *goqu.TxDatabase, logger *zap.Logger) error <span class="cov0" title="0">{
        file, err := os.Open(csvPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open review_data CSV file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        reader := csv.NewReader(file)
        _, err = reader.Read() // Read the header row
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read review_data CSV header: %w", err)
        }</span>

        <span class="cov0" title="0">expectedFields := 5

        var reviewData []map[string]interface{}
        for lineNum := 2; ; lineNum++ </span><span class="cov0" title="0">{
                row, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "EOF" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("Warning: Error reading review_data CSV row at line %d: %v\n", lineNum, err)
                        continue</span>
                }

                <span class="cov0" title="0">if len(row) != expectedFields </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Skipping review_data row at line %d with %d fields (expected %d): %v\n", lineNum, len(row), expectedFields, row)

                        continue</span>
                }

                // Trim spaces from all row values
                <span class="cov0" title="0">for i := range row </span><span class="cov0" title="0">{
                        row[i] = strings.TrimSpace(row[i])
                }</span>

                <span class="cov0" title="0">var sentimentPolarity interface{}
                if row[3] != "nan" &amp;&amp; row[3] != "NaN" </span><span class="cov0" title="0">{ // Handle both "nan" and "NaN"
                        sentimentPolarity, err = strconv.ParseFloat(row[3], 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Skipping row at line %d due to error parsing Sentiment Polarity: %v, Row: %v\n", lineNum, err, row)
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        sentimentPolarity = nil // Use nil for NULL
                }</span>

                <span class="cov0" title="0">var sentimentSubjectivity interface{}
                if row[4] != "nan" &amp;&amp; row[4] != "NaN" </span><span class="cov0" title="0">{ // Handle both "nan" and "NaN"
                        sentimentSubjectivity, err = strconv.ParseFloat(row[4], 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Skipping row at line %d due to error parsing Sentiment Subjectivity: %v, Row: %v\n", lineNum, err, row)
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        sentimentSubjectivity = nil // Use nil for NULL
                }</span>

                <span class="cov0" title="0">data := map[string]interface{}{
                        "app":                    handleString(row[0]),
                        "translated_review":      handleString(row[1]), // Changed to snake case
                        "sentiment":              handleString(row[2]),
                        "sentiment_polarity":     sentimentPolarity,     // Changed to snake case
                        "sentiment_subjectivity": sentimentSubjectivity, // Changed to snake case
                }
                reviewData = append(reviewData, data)
                fmt.Printf("Debug: Inserting review row at line %d: %v\n", lineNum, data)</span> // Log the data
        }

        <span class="cov0" title="0">_, err = tx.Insert("reviews").Rows(reviewData).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert review_data: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleString replaces "NaN" or empty strings with a default string value.
func handleString(s string) interface{} <span class="cov0" title="0">{ // Return interface{}
        if s == "NaN" || s == "nan" || strings.TrimSpace(s) == "" </span><span class="cov0" title="0">{ // Also check "nan"
                return ""
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "API Documentation for the Fiber CSV App",
        "title": "Fiber CSV App API",
        "contact": {},
        "version": "1.0"
    },
    "host": "{{.Host}}",
    "basePath": "",
    "paths": {
        "/api/v1/apps": {
            "get": {
                "description": "Retrieves a paginated list of apps from the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Get Apps",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Number of records to return",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.App"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new application entry in the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Create App",
                "parameters": [
                    {
                        "description": "App data to create",
                        "name": "app",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.App"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.App"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/apps/{id}": {
            "get": {
                "description": "Fetches an app by its ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Get App",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.App"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Updates app data in the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Update App",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated app data",
                        "name": "app",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.App"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.App"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Removes an app from the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Apps"
                ],
                "summary": "Delete App",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "App ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/reviews": {
            "get": {
                "description": "Fetches reviews from the database with pagination.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reviews"
                ],
                "summary": "Get Reviews",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Number of reviews to return",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Review"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new review in the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reviews"
                ],
                "summary": "Create Review",
                "parameters": [
                    {
                        "description": "Review data to create",
                        "name": "review",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/reviews/{id}": {
            "get": {
                "description": "Fetches a review using its ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reviews"
                ],
                "summary": "Get Review",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Updates an existing review in the database.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reviews"
                ],
                "summary": "Update Review",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated review data",
                        "name": "review",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Review"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Deletes a review by its ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reviews"
                ],
                "summary": "Delete Review",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Review ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/utils.JSONResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.App": {
            "type": "object",
            "required": [
                "app",
                "category",
                "rating",
                "reviews",
                "size",
                "installs",
                "type",
                "price",
                "content_rating",
                "genres",
                "last_updated",
                "current_ver",
                "android_ver"
            ],
            "properties": {
                "id": {
                    "type": "integer"
                },
                "app": {
                    "type": "string"
                },
                "category": {
                    "type": "string"
                },
                "rating": {
                    "type": "number"
                },
                "reviews": {
                    "type": "integer"
                },
                "size": {
                    "type": "string"
                },
                "installs": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "price": {
                    "type": "string"
                },
                "content_rating": {
                    "type": "string"
                },
                "genres": {
                    "type": "string"
                },
                "last_updated": {
                    "type": "string"
                },
                "current_ver": {
                    "type": "string"
                },
                "android_ver": {
                    "type": "string"
                }
            }
        },
        "models.NullableFloat64": {
            "type": "object",
            "properties": {
                "valid": {
                    "type": "boolean"
                },
                "value": {
                    "type": "number"
                }
            }
        },
        "models.Review": {
            "type": "object",
            "required": [
                "app",
                "sentiment",
                "translated_review"
            ],
            "properties": {
                "app": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "sentiment": {
                    "type": "string"
                },
                "sentiment_polarity": {
                    "$ref": "#/definitions/models.NullableFloat64"
                },
                "sentiment_subjectivity": {
                    "$ref": "#/definitions/models.NullableFloat64"
                }
                ,
                "translated_review": {
                    "type": "string"
                }
            }
        },
        "utils.JSONResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "status": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
    Version:          "", // Set a default version
    Host:             "", // Set a default host
    BasePath:         "", // Set a default base path
    Schemes:          []string{}, // Schemes will be marshalled by the template
    Title:            "Fiber CSV App API", // Set a default title
    Description:      "", // Set a default description
    InfoInstanceName: "swagger",
    SwaggerTemplate:  docTemplate,
    LeftDelim:        "{{",
    RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
    swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</pre>
		
		<pre class="file" id="file12" style="display: none">package logger

import (
        log "github.com/sirupsen/logrus"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var defaultEncoderConfig = zapcore.EncoderConfig{
        TimeKey:        "ts",
        LevelKey:       "level",
        NameKey:        "logger",
        CallerKey:      "caller",
        MessageKey:     "msg",
        StacktraceKey:  "stacktrace",
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    zapcore.LowercaseLevelEncoder,
        EncodeTime:     zapcore.ISO8601TimeEncoder,
        EncodeDuration: zapcore.StringDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
}

var zapServerConfig = zap.Config{
        Level:            zap.NewAtomicLevelAt(zap.InfoLevel),
        Development:      false,
        Encoding:         "json",
        EncoderConfig:    defaultEncoderConfig,
        OutputPaths:      []string{"stdout"},
        ErrorOutputPaths: []string{"stderr"},
}

// NewRootLogger instantiates zap.Logger with given configuration
func NewRootLogger(debug, developement bool) (*zap.Logger, error) <span class="cov0" title="0">{
        var err error
        var logger *zap.Logger

        if debug </span><span class="cov0" title="0">{
                // enable debug level
                zapServerConfig.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
                if !developement </span><span class="cov0" title="0">{
                        return zapServerConfig.Build(zap.AddStacktrace(zap.ErrorLevel), zap.AddCaller())
                }</span>
                <span class="cov0" title="0">zapServerConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                return zapServerConfig.Build(zap.AddStacktrace(zap.ErrorLevel), zap.AddCaller())</span>
        }

        <span class="cov0" title="0">if developement </span><span class="cov0" title="0">{
                zapServerConfig.Encoding = "console"
                zapServerConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                return zapServerConfig.Build(zap.AddStacktrace(zap.ErrorLevel), zap.AddCaller())
        }</span>

        <span class="cov0" title="0">log.SetFormatter(&amp;log.JSONFormatter{})
        logger, err = zapServerConfig.Build(zap.AddStacktrace(zap.ErrorLevel), zap.AddCaller())

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return logger, err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middlewares

import (
        "strings"

        pMetrics "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/pkg/prometheus"
        "github.com/gofiber/fiber/v2"
        "github.com/samber/lo"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var (
        zapCoreField []zapcore.Field
        // Add path that needs to excluded from logging
        ignorePathList = []string{
                "/docs",
                "/assets/redoc.css",
                "/assets/redoc.standalone.js",
                "/assets/swagger.json",
                "/favicon.ico",
        }
)

// Handler will log each request
func LogHandler(logger *zap.Logger, pMetrics *pMetrics.PrometheusMetrics) fiber.Handler <span class="cov0" title="0">{
        return func(ctx *fiber.Ctx) error </span><span class="cov0" title="0">{
                err := ctx.Next()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">exits := lo.Contains(ignorePathList, ctx.Path()) || strings.HasPrefix(string(ctx.Response().Header.ContentType()), "image/") || strings.HasPrefix(string(ctx.Response().Header.ContentType()), "text/")
                if !exits </span><span class="cov0" title="0">{
                        zapCoreField = []zapcore.Field{
                                zap.String("host", ctx.Hostname()),
                                zap.String("method", string(ctx.Request().Header.Method())),
                                zap.String("uri", ctx.BaseURL()),
                                zap.String("protocol", ctx.Protocol()),
                                zap.String("username", string(ctx.Request().URI().Username())),
                                zap.String("requestHeaders", string(ctx.Request().Header.Header())),
                                zap.String("responseHeaders", string(ctx.Response().Header.Header())),
                                zap.String("request", string(ctx.Request().Body())),
                                zap.String("response", ctx.Response().String()),
                                zap.Int("status", ctx.Response().Header.StatusCode()),
                                zap.Int("size", ctx.Response().Header.ContentLength()),
                        }
                        if ctx.Response().Header.StatusCode() &gt;= 100 &amp;&amp; ctx.Response().Header.StatusCode() &lt;= 399 </span><span class="cov0" title="0">{
                                logger.Debug("Handled successful request", zapCoreField...)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Error("handled error request", zapCoreField...)
                        }</span>
                }

                // For /metrics endpoint count in next request
                // Because /metrics endpoint response is send first and
                // Respected status code counter increase next
                <span class="cov0" title="0">if ctx.Response().StatusCode() &gt;= 200 &amp;&amp; ctx.Response().StatusCode() &lt; 300 </span><span class="cov0" title="0">{
                        pMetrics.RequestsMetrics.WithLabelValues("2xx").Inc()
                }</span> else<span class="cov0" title="0"> if ctx.Response().StatusCode() &gt;= 300 &amp;&amp; ctx.Response().StatusCode() &lt; 400 </span><span class="cov0" title="0">{
                        pMetrics.RequestsMetrics.WithLabelValues("3xx").Inc()
                }</span> else<span class="cov0" title="0"> if ctx.Response().StatusCode() &gt;= 400 &amp;&amp; ctx.Response().StatusCode() &lt; 500 </span><span class="cov0" title="0">{
                        pMetrics.RequestsMetrics.WithLabelValues("4xx").Inc()
                }</span> else<span class="cov0" title="0"> if ctx.Response().StatusCode() &gt;= 500 </span><span class="cov0" title="0">{
                        pMetrics.RequestsMetrics.WithLabelValues("5xx").Inc()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middlewares

import (
        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/config"
        "go.uber.org/zap"
)

type Middleware struct {
        config config.AppConfig
        logger *zap.Logger
}

func NewMiddleware(cfg config.AppConfig, logger *zap.Logger) Middleware <span class="cov0" title="0">{
        return Middleware{
                config: cfg,
                logger: logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "database/sql"

        "github.com/doug-martin/goqu/v9"
)

// AppTable represent table name
const AppTable = "apps"

// App model
type App struct {
        AppId         int     `json:"id" db:"id"`
        App           string  `json:"app" db:"app" validate:"required"`
        Category      string  `json:"category" db:"category" validate:"required"`
        Rating        float64 `json:"rating" db:"rating" validate:"required"`
        Reviews       int     `json:"reviews" db:"reviews" validate:"required"`
        Size          string  `json:"size" db:"size" validate:"required"`
        Installs      string  `json:"installs" db:"installs" validate:"required"`
        Type          string  `json:"type" db:"type" validate:"required"`
        Price         string  `json:"price" db:"price" validate:"required"`
        ContentRating string  `json:"content_rating" db:"content_rating" validate:"required"`
        Genres        string  `json:"genres" db:"genres" validate:"required"`
        LastUpdated   string  `json:"last_updated" db:"last_updated" validate:"required"`
        CurrentVer    string  `json:"current_ver" db:"current_ver" validate:"required"`
        AndroidVer    string  `json:"android_ver" db:"android_ver" validate:"required"`
}

// AppModel implements app related database operations
type AppModel struct {
        db *goqu.Database
}

// InitAppModel Init model
func InitAppModel(goqu *goqu.Database) (AppModel, error) <span class="cov0" title="0">{
        return AppModel{
                db: goqu,
        }, nil
}</span>

// GetApps lists all apps.
func (model *AppModel) GetApps(limit, offset int) ([]App, error) <span class="cov0" title="0">{
        var apps []App
        query := model.db.From(AppTable)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(uint(limit))
        }</span>
        <span class="cov0" title="0">if offset &gt;= 0 </span><span class="cov0" title="0">{
                query = query.Offset(uint(offset))
        }</span>

        <span class="cov0" title="0">if err := query.ScanStructs(&amp;apps); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return apps, nil</span>
}

// GetById gets an app by its ID.  It retrieves all fields from the database.
func (model *AppModel) GetAppById(id int) (App, error) <span class="cov0" title="0">{
        app := App{}
        found, err := model.db.From(AppTable).Where(goqu.Ex{
                "id": id,
        }).ScanStruct(&amp;app)

        if err != nil </span><span class="cov0" title="0">{
                return app, err
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return app, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return app, nil</span>
}

// InsertApps inserts a new app into the database.
// For AppModel with database-generated ID (SERIAL)
// InsertApps inserts a new app into the database.
func (model *AppModel) InsertApps(app App) (App, error) <span class="cov0" title="0">{
        var insertedID int64

        _, err := model.db.Insert(AppTable).
                Rows(goqu.Record{
                        "app":            app.App,
                        "category":       app.Category,
                        "rating":         app.Rating,
                        "reviews":        app.Reviews,
                        "size":           app.Size,
                        "installs":       app.Installs,
                        "type":           app.Type,
                        "price":          app.Price,
                        "content_rating": app.ContentRating,
                        "genres":         app.Genres,
                        "last_updated":   app.LastUpdated,
                        "current_ver":    app.CurrentVer,
                        "android_ver":    app.AndroidVer,
                }).
                Returning("id"). // This makes PostgreSQL return the inserted ID
                Executor().
                ScanVal(&amp;insertedID)

        if err != nil </span><span class="cov0" title="0">{
                return App{}, err
        }</span>

        <span class="cov0" title="0">app.AppId = int(insertedID)
        return app, nil</span>
}

func (model *AppModel) DeleteApp(id int) error <span class="cov0" title="0">{
        result, err := model.db.Delete(AppTable).Where(goqu.Ex{
                "id": id,
        }).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows // Return a specific error for "not found"
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (model *AppModel) UpdateApp(id int, app App) (App, error) <span class="cov0" title="0">{
        result, err := model.db.Update(AppTable).Set(goqu.Record{
                "app":            app.App,
                "category":       app.Category,
                "rating":         app.Rating,
                "reviews":        app.Reviews,
                "size":           app.Size,
                "installs":       app.Installs,
                "type":           app.Type,
                "price":          app.Price,
                "content_rating": app.ContentRating,
                "genres":         app.Genres,
                "last_updated":   app.LastUpdated,
                "current_ver":    app.CurrentVer,
                "android_ver":    app.AndroidVer,
        }).Where(goqu.Ex{"id": id}).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return App{}, err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return App{}, err
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return App{}, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">app.AppId = id
        return app, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "database/sql"
        "database/sql/driver"
        "encoding/json"
        "fmt"

        "github.com/doug-martin/goqu/v9"
)

// ReviewTable represent table name
const ReviewTable = "reviews"

// Review model
type Review struct {
        ReviewID              int             `json:"id" db:"id"`
        App                   string          `json:"app" db:"app" validate:"required"`
        TranslatedReview      string          `json:"translated_review" db:"translated_review" validate:"required"`
        Sentiment             string          `json:"sentiment" db:"sentiment" validate:"required"`
        SentimentPolarity     NullableFloat64 `json:"sentiment_polarity" db:"sentiment_polarity"`
        SentimentSubjectivity NullableFloat64 `json:"sentiment_subjectivity" db:"sentiment_subjectivity"`
}

// ReviewModel implements review related database operations
type ReviewModel struct {
        db *goqu.Database
}

// because swagger does not handle sql.Nullfloat64 directly
type NullableFloat64 struct {
        Float64 float64 `json:"value" swaggertype:"primitive,number"`
        Valid   bool    `json:"valid" swaggertype:"primitive,boolean"`
}

// MarshalJSON implements json.Marshaler interface
func (nf NullableFloat64) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if !nf.Valid </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(nf.Float64)</span>
}

// UnmarshalJSON implements json.Unmarshaler interface
func (nf *NullableFloat64) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // If the input is null, set Valid to false
        if string(data) == "null" </span><span class="cov0" title="0">{
                nf.Valid = false
                return nil
        }</span>

        // Otherwise try to unmarshal into float64
        <span class="cov0" title="0">var f float64
        if err := json.Unmarshal(data, &amp;f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nf.Float64 = f
        nf.Valid = true
        return nil</span>
}

// Scan implements the sql.Scanner interface
func (nf *NullableFloat64) Scan(value interface{}) error <span class="cov0" title="0">{
        var f sql.NullFloat64
        if err := f.Scan(value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nf.Float64 = f.Float64
        nf.Valid = f.Valid
        return nil</span>
}

// Value implements the driver.Valuer interface
func (nf NullableFloat64) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !nf.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return nf.Float64, nil</span>
}

// String returns a string representation of the value
func (nf NullableFloat64) String() string <span class="cov0" title="0">{
        if !nf.Valid </span><span class="cov0" title="0">{
                return "NULL"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%f", nf.Float64)</span>
}

// InitReviewModel Init model
func InitReviewModel(goqu *goqu.Database) (ReviewModel, error) <span class="cov0" title="0">{
        return ReviewModel{
                db: goqu,
        }, nil
}</span>

// GetReviews lists all reviews.
func (model *ReviewModel) GetReviews(limit, offset int) ([]Review, error) <span class="cov0" title="0">{
        var reviews []Review
        query := model.db.From(ReviewTable)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(uint(limit))
        }</span>
        <span class="cov0" title="0">if offset &gt;= 0 </span><span class="cov0" title="0">{
                query = query.Offset(uint(offset))
        }</span>

        <span class="cov0" title="0">if err := query.ScanStructs(&amp;reviews); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return reviews, nil</span>
}

// GetById gets a review by its ID.
func (model *ReviewModel) GetReviewById(id int) (Review, error) <span class="cov0" title="0">{
        review := Review{}
        found, err := model.db.From(ReviewTable).Where(goqu.Ex{
                "id": id,
        }).ScanStruct(&amp;review)

        if err != nil </span><span class="cov0" title="0">{
                return review, err
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return review, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return review, nil</span>
}

// InsertReviews inserts a new review into the database.
// InsertReviews inserts a new review into the database.
func (model *ReviewModel) InsertReviews(review Review) (Review, error) <span class="cov0" title="0">{
        var insertedID int64

        _, err := model.db.Insert(ReviewTable).
                Rows(goqu.Record{
                        "app":                    review.App,
                        "translated_review":      review.TranslatedReview,
                        "sentiment":              review.Sentiment,
                        "sentiment_polarity":     review.SentimentPolarity,
                        "sentiment_subjectivity": review.SentimentSubjectivity,
                }).
                Returning("id"). // Get the ID of the inserted row
                Executor().
                ScanVal(&amp;insertedID)

        if err != nil </span><span class="cov0" title="0">{
                return Review{}, err
        }</span>

        <span class="cov0" title="0">review.ReviewID = int(insertedID)
        return review, nil</span>
}

// DeleteApp deletes a review by its ID.
func (model *ReviewModel) DeleteApp(id int) error <span class="cov0" title="0">{
        result, err := model.db.Delete(ReviewTable).Where(goqu.Ex{
                "id": id,
        }).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows // Return a specific error for "not found"
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateReview updates an existing review in the database.
func (model *ReviewModel) UpdateReview(id int, review Review) (Review, error) <span class="cov0" title="0">{
        result, err := model.db.Update(ReviewTable).Set(goqu.Record{
                "app":                    review.App,
                "translated_review":      review.TranslatedReview,
                "sentiment":              review.Sentiment,
                "sentiment_polarity":     review.SentimentPolarity,
                "sentiment_subjectivity": review.SentimentSubjectivity,
        }).Where(goqu.Ex{"id": id}).Executor().Exec()
        if err != nil </span><span class="cov0" title="0">{
                return Review{}, err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return Review{}, err
        }</span>
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return Review{}, sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">review.ReviewID = id
        return review, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package prometheus

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

const Namespace = "golang_api"

type PrometheusMetrics struct {
        RequestsMetrics *prometheus.CounterVec
}

var metrics *PrometheusMetrics = nil

func InitPrometheusMetrics() *PrometheusMetrics <span class="cov0" title="0">{
        if metrics == nil </span><span class="cov0" title="0">{
                metrics = &amp;PrometheusMetrics{
                        RequestsMetrics: promauto.NewCounterVec(prometheus.CounterOpts{
                                Namespace: Namespace,
                                Name:      "requests_total",
                                Help:      "Total API requests",
                        }, []string{"code"}),
                }
        }</span>

        <span class="cov0" title="0">return metrics</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package routes

import (
        "fmt"

        "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/constants"
        controllers "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/controllers/api/v1"
        "github.com/doug-martin/goqu/v9"
        "github.com/gofiber/fiber/v2"
        "go.uber.org/zap"

        // Adjust the import path if necessary
        pMetrics "git.pride.improwised.dev/Onboarding-2025/Yash-Tilala/fiber-csv-app/pkg/prometheus"
)

// Setup function to include App routes
func Setup(app *fiber.App, goqu *goqu.Database, logger *zap.Logger, pMetrics *pMetrics.PrometheusMetrics) error <span class="cov0" title="0">{ // Added pMetrics
        router := app.Group("/api")
        v1 := router.Group("/v1")

        // Setup other routes...
        err := setupAppController(v1, goqu, logger, pMetrics) // Pass pMetrics
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Setup Review routes
        <span class="cov0" title="0">err = setupReviewController(v1, goqu, logger, pMetrics)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = healthCheckController(app, goqu, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func setupAppController(v1 fiber.Router, goqu *goqu.Database, logger *zap.Logger, pMetrics *pMetrics.PrometheusMetrics) error <span class="cov0" title="0">{ // Added pMetrics
        appController, err := controllers.NewAppController(goqu, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appRouter := v1.Group("/apps") // Define the /apps route group

        // Define the specific routes within the /apps group
        appRouter.Get(fmt.Sprintf("/:%s", constants.ParamAppID), appController.GetApp) // GET /api/v1/apps/:appId
        appRouter.Get("/", appController.GetApps)
        appRouter.Post("/", appController.CreateApp) // GET /api/v1/apps/
        appRouter.Delete(fmt.Sprintf("/:%s", constants.ParamAppID), appController.DeleteApp)
        appRouter.Put(fmt.Sprintf("/:%s", constants.ParamAppID), appController.UpdateApp)
        return nil</span>
}
func setupReviewController(v1 fiber.Router, goqu *goqu.Database, logger *zap.Logger, pMetrics *pMetrics.PrometheusMetrics) error <span class="cov0" title="0">{
        reviewController, err := controllers.NewReviewController(goqu, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">reviewRouter := v1.Group("/reviews")

        reviewRouter.Get(fmt.Sprintf("/:%s", constants.ParamReviewID), reviewController.GetReview) // GET /api/v1/reviews/:id
        reviewRouter.Get("/", reviewController.GetReviews)
        reviewRouter.Post("/", reviewController.CreateReviewData)
        reviewRouter.Delete(fmt.Sprintf("/:%s", constants.ParamReviewID), reviewController.DeleteReview)
        reviewRouter.Put(fmt.Sprintf("/:%s", constants.ParamReviewID), reviewController.UpdateReview)

        return nil</span>
}
func healthCheckController(app *fiber.App, goqu *goqu.Database, logger *zap.Logger) error <span class="cov0" title="0">{
        healthController, err := controllers.NewHealthController(goqu, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">healthz := app.Group("/healthz")
        healthz.Get("/", healthController.Overall)
        healthz.Get("/db", healthController.Db)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package routinewrapper

import (
        "sync"
)

var handle func()
var _once sync.Once

func Init(fn func()) <span class="cov0" title="0">{
        _once.Do(func() </span><span class="cov0" title="0">{
                // this sets the global handle function
                handle = fn
        }</span>)
}

func RoutineGenerator(fn func()) <span class="cov0" title="0">{
        defer handle()
        fn()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package utils

import (
        "clevergo.tech/jsend"
        "github.com/gofiber/fiber/v2"
)

type JSONResponse struct {
        Status string      `json:"status"`
        Data   interface{} `json:"data"`
}

// JSONSuccess is a generic success output writer
func JSONSuccess(c *fiber.Ctx, statusCode int, data interface{}) error <span class="cov0" title="0">{
        return c.Status(statusCode).JSON(jsend.New(data))
}</span>

// JSONFail is a generic fail output writer
// JSONFail can used for 4xx status code response
func JSONFail(c *fiber.Ctx, statusCode int, data interface{}) error <span class="cov0" title="0">{
        return c.Status(statusCode).JSON(jsend.NewFail(data))
}</span>

// JSONError is a generic error output writer
// JSONError can used for 5xx status code response
func JSONError(c *fiber.Ctx, statusCode int, err string) error <span class="cov0" title="0">{
        return c.Status(statusCode).JSON(jsend.NewError(err, statusCode, nil))
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package utils

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/go-playground/validator/v10"
)

const VALIDATE_MESSAGE = "fields are invalid."

func ValidateEmail(email string) (bool, error) <span class="cov0" title="0">{
        return regexp.MatchString("[a-zA-z]+@improwised.com", email)
}</span>

func ValidatorErrorString(err error) string <span class="cov0" title="0">{
        var msg string
        if err != nil </span><span class="cov0" title="0">{
                for _, err := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                        msg += strings.ToLower(err.Field()) + ","
                }</span>
                <span class="cov0" title="0">msg = strings.TrimSuffix(msg, ",")
                msg = fmt.Sprintf("%s %s", msg, VALIDATE_MESSAGE)
                return msg</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
